<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Mastering of the Elements Game</title>
    <meta name="description" content="A unique and beautiful idea for a game that lets you master the elements of the universe!">
    <meta name="author" content="Robert Ireland">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

    <style>
        canvas {
            border: 1px solid #d3d3d3;
            background-color: #f1f1f1;
        }
        #canvasLocation {
            /* margin-top: 20px; */
            /* margin-left: 4.5%; */
            position: absolute;
            top: 15px;/*50%;*/
            left: 50%;
            -ms-transform: translate(-50%, 0%);
            /* , -50%); */
            transform: translate(-50%, 0%)
            /* , -50%); */
        }
        #startButton {
            margin: 10px;
            position: absolute;
            /* top: 50%; */
            bottom: 20%;
            left: 50%;
            -ms-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>

<!-- </body> onkeydown=""> -->
    <!-- onkeydown="keyWasPressed(event)" -->

    <!-- I'm first going to try and make as much of this game in canvas since I will be able to have almost all the control that I want, and it
    will be as cross platform as it can get at that point. And the future will bring more ease of adding new controls/signals/outside interactions -->

<p id="canvasLocation"></p>
<p></p>
<!-- make the button dissapear after pressing start -->
<button id="startButton" onclick="startGame(); document.body.setAttribute('onkeydown', 'keyWasPressed(event)'); document.body.setAttribute('onkeyup', 'keyWasReleased(event)'); this.style.display='none'"> Start Game </button>
<!-- document.getElementById('tagName').setAttribute('onkeydown', 'keyWasPressed(event)'); This allows key presses to be listed for after start is pressed-->

<script>
function startGame() {
    myGameArea.start();

    // creates the player hero char:
    me_ThePlayer1CharacterHero = new me_ThePlayer1CharacterHero();

    // create a few game objs
    block1 = new blockComponent(100, 320, 30, 30, "red", 10, "fire");
    block2 = new blockComponent(220, 200, 50, 50, "gray", 150, "metal");
    ball1 = new ballComponent(600, 300, 50, "blue", true, 80, "water");

    controllableGameObjs["block1"] = block1;
    controllableGameObjs["block2"] = block2;
    controllableGameObjs["ball1"] = ball1;
}

// any game obj that I can potentially control should be in here.
var controllableGameObjs = {};


// This function runs on a timer. Every tick (20ms for 50FPS), the entire screen gets cleared and the objs in the canvas get updated
function updateGameArea() {
    myGameArea.clear(); // clear the screen before updating obj positions and calling update on the moved objs.

    // How should I determine how an object knows the player wants to control it.
    // I would like to control the elements in a variety of ways. Like making walls or picking up mounds of dirt.
    // I need a way to be able to control only a single specific chunk/ball/group of elements, as well as those in front of me, and those all around me.
    // I would also like to be able to move objects left and right (x axis), as well as in front and behind me (along the z axis).
    // It would also be cool to precisely control the direction of the element chunk. I can think of how I might build a glove or one handed controller to
    // control things later. Currently, I need to incorporate non vertical forces on the elements, each with their own buttons

    // Tell the ball1 that player1 is actively trying to control it
    ball1.isUnderMyControl = true;
    block1.isUnderMyControl = true;
    block2.isUnderMyControl = true;
    me_ThePlayer1CharacterHero.objImControlling = ball1;
    

    // Calculate gravity for every obj:
    // If the obj moved, update the drawing for ball1:
    gravity(ball1);
    gravity(block1);
    gravity(block2);
    

    // Update all the objs that were or will be visible (so that they can get redrawn to the screen) after every clear screen call
    ball1.update();
    block1.update();
    block2.update();
}





function me_ThePlayer1CharacterHero(x=0, y=0, z=0, hipRotationY=0, leftArmAimingX=0, leftArmAimingY=screen.availHeight, rightArmAimingX=screen.width, rightArmAimingY=screen.availHeight, mass=100, waterForcePower=0, fireForcePower=0, airForcePower=0, rockForcePower=0, metalForcePower=0, electricityForcePower=0, laserForcePower=0, staminaEnergy=100, punchingPower=10, flyingSpeed=0, flyingAcceleration=0, runningSpeed=10, runningAcceleration=10, jumpingHeight=1, swimmingSpeed=1) {
    this.waterForcePower=waterForcePower;
    this.fireForcePower=fireForcePower;
    this.airForcePower=airForcePower;
    this.rockForcePower=rockForcePower;
    this.metalForcePower=metalForcePower;
    this.electricityForcePower=electricityForcePower;
    this.laserForcePower=laserForcePower;
    this.staminaEnergy=staminaEnergy; 
    this.punchingPower=punchingPower;
    this.flyingSpeed=flyingSpeed;
    this.flyingAcceleration=flyingAcceleration; 
    this.runningSpeed=runningSpeed; 
    this.runningAcceleration=runningAcceleration; 
    this.jumpingHeight=jumpingHeight;
    this.swimmingSpeed=swimmingSpeed;
    this.x = x;
    this.y = y;
    this.z = z;
    this.hipRotationY=hipRotationY;
    this.leftArmAimingX = leftArmAimingX;
    this.leftArmAimingY = leftArmAimingY;
    this.rightArmAimingX = rightArmAimingX;
    this.rightArmAimingY = rightArmAimingY;
    this.mass = mass;
    this.tryingToForceHoldObjSteady = false;
    this.tryingToForceLiftObjUp = false;
    this.tryingToForceThrowObjDown = false;
    this.exertingForce = 0; // this should change as I try to change what i want to do. the exertingForce should increase when I want to throw something up
    this.objImControlling = null;
    this.myElementSkillSet = {water: 20, fire: 20, ice: 20, air: 20, rock: 20, metal: 20, electricity: 20, laser: 20};
    this.maxMassToBeForceHeld = {water: 100, fire: 100, ice: 100, air: 100, rock: 100, metal: 100, electricity: 100, laser: 100}; // this gets larger as the player levels up/masters the elements
    this.massControlPercent = 1; // percent/100 from 0 to 1. Controls how much mass max I want to be able to hold steady
    this.tryingToForceObjLeft = false;
    this.tryingToForceObjRight = false;
    this.tryingToForceObjForward = false;
    this.tryingToForceObjBack = false;
    this.moveForward = false;
    this.moveBackward = false;
    this.moveLeft = false;
    this.moveRight = false;
    this.rotateLeft = false;
    this.rotateRight = false;
    // this.ctx = myGameArea.context;
    // I'm not going to draw the player character to the screen for now since I want this to be a 1st person game
    // I will work on drawing the arms to the screen later. And I will later determine how to calculate where the player
    // is aiming their arms with a dot that shows the position.
    // this.update = function() {
    //     if (leftArmUp == true) {
    //         ctx=myGameArea.context;
    //         // If I'm not doing vr would like to draw arms to the screen that have the same orientation as player 1's arms
    //         // draw the arms as they are on the player in real life

    //     }
    // }
}

// I need a way to adjust how much mass I want to be able to control. I will be doing this with the controller, so I can use a few buttons for now. 10 to 100% 



// When I press the d key, I would like to increase the vertical acceleration on the circle ball1
function keyWasPressed(event) {
    // var keyCode = event.which || event.keyCode;
    var keyCode = event.keyCode;
    if (keyCode >= 65 && keyCode <= 90) {
        keyCode +=32;
    }    
    var pressedKey = String.fromCharCode(keyCode);  //String.fromCodePoint(x);     // Convert the value into a character
    if (pressedKey == 'd') { // decelerate the obj and hold the obj steady
        // console.log("d was pressed");
        me_ThePlayer1CharacterHero.tryingToForceHoldObjSteady = true;
    } else if (pressedKey == 'e') { // lift and accel the obj in the air
        me_ThePlayer1CharacterHero.tryingToForceLiftObjUp = true;
    } else if (pressedKey == 'f') { // throw the obj down
        me_ThePlayer1CharacterHero.tryingToForceThrowObjDown = true;
    }
    // adjust the amount of mass that is to be steadily controlled:
    else if (pressedKey == '1') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.1;
    } else if (pressedKey == '2') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.2;
    } else if (pressedKey == '3') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.3;
    } else if (pressedKey == '4') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.4;
    } else if (pressedKey == '5') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.5;
    } else if (pressedKey == '6') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.6;
    } else if (pressedKey == '7') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.7;
    } else if (pressedKey == '8') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.8;
    } else if (pressedKey == '9') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 0.9;
    } else if (pressedKey == '0') { // throw the obj down
        me_ThePlayer1CharacterHero.massControlPercent = 1;
    } 
    // when the player tries to move the object in non y direction:
    // In order to know what direction I want the objects to move in, everything will be
    // relevant to where the player1 is looking. To accelerate an object to the left means I would need
    // to be looking in some direction, and have control of a substance. Then, I would apply a constant force
    // on the object. The y axis was universal for gravity and rising forces, but the l/r x and f/b z axis change w player1
    // If I am still trying to hold an object steady after I move it left/R or F/B, I would like it to decelerate in the same way
    // as it does when up/down. 
    else if (pressedKey == 'j') { // accelerate obj left
        me_ThePlayer1CharacterHero.tryingToForceObjLeft = true;
    } else if (pressedKey == 'k') { // accel obj right
        me_ThePlayer1CharacterHero.tryingToForceObjRight = true;
    } else if (pressedKey == 'i') { // accel obj forward
        me_ThePlayer1CharacterHero.tryingToForceObjForward = true;
    } else if (pressedKey == ',') { // accel obj back
        me_ThePlayer1CharacterHero.tryingToForceObjBack = true;
    } 

    // I think I would like to be able to move/rotate the character with the joysticks
    else if (keyCode == 38) { // move forward
        me_ThePlayer1CharacterHero.moveForward = true;
    } else if (keyCode == 40) { // move back
        me_ThePlayer1CharacterHero.moveBackward = true;
    } else if (keyCode == 37) { // move left
        me_ThePlayer1CharacterHero.moveLeft = true;
    } else if (keyCode == 39) { // move right
        me_ThePlayer1CharacterHero.moveRight = true;
    } 
    // rotate:
    else if (keyCode == 37) { // rotate left
        me_ThePlayer1CharacterHero.rotateLeft = true;
    } else if (keyCode == 39) { // rotate right
        me_ThePlayer1CharacterHero.rotateRight = true;
    } 
    // In order to accelerate player1 up, they need to use their force to accelerate the earth or something touching the ground downward

    else {
        console.log("A key was pressed");
        console.log(pressedKey);
        console.log("The keyCode is:");
        console.log(keyCode);
    }
}



function keyWasReleased(event) {
    me_ThePlayer1CharacterHero.tryingToForceHoldObjSteady = false;
    me_ThePlayer1CharacterHero.tryingToForceLiftObjUp = false;
    me_ThePlayer1CharacterHero.tryingToForceThrowObjDown = false;
    me_ThePlayer1CharacterHero.exertingForce = 0;
    var keyCode = event.keyCode;
    if (keyCode >= 65 && keyCode <= 90) {
        keyCode +=32;
    }    
    var releasedKey = String.fromCharCode(keyCode);  //String.fromCodePoint(x);     // Convert the value into a character
    if (releasedKey == 'd') {
        for (obj in controllableGameObjs) {
            obj.holdObjSteadyAtThisHeightInMeters = 0;
        }
    }
        // console.log("key was released")
}

// I would like to make sure that objects with low masses don't oscillate rapidly when I try to hold them steady

function sumOfForces(obj) {
    if (obj.isUnderMyControl == true) { // if I have an obj under my control, make sure the exertingForce is correct given the input
        // console.log("me_ThePlayer1CharacterHero.exertingForce")
        var myElementalPowerRating = me_ThePlayer1CharacterHero.myElementSkillSet[obj.elementType];
        var maxElementalForce = 0;
        // make sure I got a number!
        if (myElementalPowerRating != NaN) {
            maxElementalForce = myElementalPowerRating * me_ThePlayer1CharacterHero.maxMassToBeForceHeld[obj.elementType] * me_ThePlayer1CharacterHero.massControlPercent; //obj.mass; // this is the max force that I can issue against this element type
        }
        if (me_ThePlayer1CharacterHero.tryingToForceHoldObjSteady == true) {
            // There are two situations I will run into right now
            // if the obj is on the ground, I need to lift it up with an acceleration force up
            // if the obj is falling, I need to decelerate it and then hold it steady
            // I want to exert a force only if the obj isn't moving
            // I would like the falling/rising object to slowly settle into 0 velocity position with no oscillation at first
            // I need to know what the height of the object was that I want to hold steady. Then I can work towards getting the object near that height
            if (maxElementalForce > obj.mass * GRAVITY) { // If I'm able to hold the object up and steady
                if (obj.holdObjSteadyAtThisHeightInMeters == 0) {
                    obj.holdObjSteadyAtThisHeightInMeters = obj.objMetersAboveGround;
                }
                // if the obj rose or fell at 1/3rd a meter from where I tried to stop it, reset the stopping point
                if (Math.abs(obj.holdObjSteadyAtThisHeightInMeters - obj.objMetersAboveGround) > 0.3) {
                    obj.holdObjSteadyAtThisHeightInMeters = obj.objMetersAboveGround;
                }

                // PID
                if (obj.objMetersAboveGround < obj.holdObjSteadyAtThisHeightInMeters) { // if the object is below the hold obj steady point
                    if (obj.objVelocity > -0.01) { // if obj is moving up, I want to cancel gravity's force to give constant velocity
                        me_ThePlayer1CharacterHero.exertingForce = GRAVITY * obj.mass; // constant force against gravity did much better than: maxElementalForce;
                    } else if (obj.objVelocity == 0) { // if obj is moving up, I want to cancel gravity's force to give constant velocity
                        me_ThePlayer1CharacterHero.exertingForce = GRAVITY * obj.mass; // constant force against gravity did much better than: maxElementalForce;
                    } else { // if obj is moving down
                        me_ThePlayer1CharacterHero.exertingForce = maxElementalForce;
                    }
                } else  { //if (obj.objMetersAboveGround > holdObjSteadyAtThisHeightInMeters) { // if the object is above the hold obj steady point
                    if (obj.objVelocity > -0.01) { // if obj is moving up, I only want to apply a negative force
                        me_ThePlayer1CharacterHero.exertingForce = -1*maxElementalForce; // apply max negative force
                    } else { // if obj is moving down or still
                        me_ThePlayer1CharacterHero.exertingForce = GRAVITY * obj.mass; // apply up force to cancel gravity and try and get constant velocity
                    }
                }
            } else { // the object's mass is too large to hold steady
                // give it everything I've got
                if (obj.objVelocity <= 0) { // if obj is falling or still, provide upward force
                    me_ThePlayer1CharacterHero.exertingForce = maxElementalForce;
                } else { // if obj is moving up, try to slow it down
                    me_ThePlayer1CharacterHero.exertingForce = -1*maxElementalForce;
                }
            }
        } else if (me_ThePlayer1CharacterHero.tryingToForceLiftObjUp == true) {
            me_ThePlayer1CharacterHero.exertingForce = maxElementalForce;
        } else if (me_ThePlayer1CharacterHero.tryingToForceThrowObjDown == true) { // throw the obj down
            me_ThePlayer1CharacterHero.exertingForce = -maxElementalForce;
        } else {
            me_ThePlayer1CharacterHero.exertingForce = 0;
        }
        return -1*GRAVITY*obj.mass + me_ThePlayer1CharacterHero.exertingForce;
    }
    return -1*GRAVITY*obj.mass; // gravity down is the default option
}

var GRAVITY = 10;//m/s^2

// call gravity on an obj to make sure it falls towards earth
function gravity(obj) {
    // I need to convert obj height from pixels to meters before applying kinematic laws:
    // var objPixelHeight_y = obj.objHeight(); // this is height in pixels from the top of the screen. I would like height in meters from the ground
    // constant acceleration kinematic equations
    // Determine the height from the ground in meters:
    var objMetersAboveGround_y = obj.objMetersAboveGround;// the obj itself needs to keep track of how high it is off the ground in meters
    // Ground is 0m above ground for now.

    // calculate sum of accelerations on the object before updating the initial velocity
    var sumOfAccelerations_y = sumOfForces(obj) / obj.mass;
    // Now update the initial velocity
    var objInitialVelocity_y = obj.objVelocity; // I'll keep this in meters/sec all the time

    // The finalVelocity is needed to keep track of the correct objInitialVelocity_y
    // var finalVelocity_y = objInitialVelocity_y + sumOfAccelerations_y * deltaTime;
    var finalVelocity_y = objInitialVelocity_y + sumOfAccelerations_y * deltaTime;
    // The finalPosition_y tells me where's the maximum distance the obj should be (unless there is something under it or a new force on it)
    var finalPosition_y = objMetersAboveGround_y + objInitialVelocity_y*deltaTime + 0.5*sumOfAccelerations_y*(deltaTime**2);
    
    // I need to convert finalPosition_y from meters to pixels from the top of the screen
    // I need to know how many meters tall my screen is, what direction/orientation my screen is looking at, where my screen is located, 
    // etc. To simplify the process for a 2d simulation, I will assume basic viewing options for now
    // To determine the obj's final position in pixels, where the bottom of the screen is ground and the top of the screen is some distance above the objs.
    // The obj is going to fall a little bit, if I know how high up it was it meters and in pixels, and I know how many pixels is at the bottom of the screen and 0 meters,
    // I can figure out where it's located in pixels:
    var numPixels_y = myGameArea.canvasHeight;
    // var ball_x // determine how far the ball is from my eyes and then update 6 meters to the correct distance the ball is from my eyes
    var finalObjPixelHeight_y = numPixels_y+(-1*numPixels_y/6)*finalPosition_y; // assuming the ball's x position is 6m away from me

    // now I can update objHeight_y and velocity if they aren't going to hit the ground. Otherwise, I need to draw them on the ground
    if (finalObjPixelHeight_y >= myGameArea.canvasHeight) {
        var numPixelsAboveGround = 1;
        // If the ball would go past the canvas ground if it wasn't for me:
        // set the ball on the ground with no bounce:
        finalObjPixelHeight_y = myGameArea.canvasHeight-numPixelsAboveGround;
        finalPosition_y = numPixelsAboveGround/(numPixels_y+(-1*numPixels_y/6));
        finalVelocity_y = 0;
    }
    obj.y = finalObjPixelHeight_y; // obj.y needs to be the very bottom y position of the obj
    obj.objVelocity = finalVelocity_y;
    obj.objMetersAboveGround = finalPosition_y; // I need to update the obj height above ground
}



// elementType="Water", Rock, Fire, air, metal, electricity, laser

// draw an circle/ball to the canvas:
function ballComponent(x, y, radius, color, filled=true, mass=50, elementType="water", objVelocity=0, objMetersAboveGround=4) {
    this.objMetersAboveGround = objMetersAboveGround;
    this.objVelocity = objVelocity;
    this.elementType = elementType;
    this.isUnderMyControl = false;
    // this.gravity = gravity; // default 10m/s^2
    this.mass = mass; // this is the mass of the ball in Kg
    // this.weight = this.mass * 10; // default weight is 300N
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.objHeight = function() {return this.y + this.radius;};
    this.filled = filled;
    this.holdObjSteadyAtThisHeightInMeters = 0; // Use this to keep track of where the obj should stay at when being held steady
    // update is needed for redrawing the component to the canvas every tick
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(this.x-this.radius, this.y-this.radius, this.radius, 0, 2 * Math.PI);
        if (this.filled == true) {
            ctx.fill();
        } else {
            ctx.stroke();
        }
    }
    // this.gravityUpdate = function() {
    //     if ((this.y+this.radius) < ctx.height) {
    //         this.y = this.y + 1; // I would like position, velocity, and sum of acceration forces in the x,y, and z axis being calculated here
    //     }
    // }
}

// draw a square/rectangle/block to canvas
function blockComponent(x, y, width, height, color, mass=100, elementType="rock", objVelocity=0, objMetersAboveGround=4) {
    this.objMetersAboveGround = objMetersAboveGround;
    this.objVelocity = objVelocity;
    this.elementType = elementType;
    this.isUnderMyControl = false;
    this.mass = mass; // this is the mass of the block in Kg
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    this.objHeight = function() {return this.y + this.height;};
    this.holdObjSteadyAtThisHeightInMeters = 0; // Use this to keep track of where the obj should stay at when being held steady
    this.color = color;
    this.update = function() {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x-this.width, this.y-this.height, this.width, this.height);
    }
}

var screenHeightPercent = 0.80;
var screenWidthPercent = 0.90;

// In the myGameArea obj, there's an interval which will run the updateGameArea() 
// function every 20th millisecond (50 times per second). Also there's a function called clear(), that clears the entire canvas.
var myGameArea = {
    canvasHeight : screenHeightPercent*screen.availHeight,
    canvasWidth : screenWidthPercent*screen.width,
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = screenWidthPercent*screen.width;
        this.canvas.height = screenHeightPercent*screen.availHeight;
        this.context = this.canvas.getContext("2d");
        document.getElementById("canvasLocation").appendChild(this.canvas);
        // create a timer with setInterval that triggers updateGameArea() to get called every 20ms (50FPS)
        this.interval = setInterval(updateGameArea, _50FPS);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); // clear the entire canvas
    }
}

var _50FPS = 20; // 1/(20*10^-3) == 50 FPS == 1/20ms
// var _40FPS = 25;
// var _30FPS = 33.3;

// var deltaTime = _50FPS*10**-3; // 20ms // 0.020
var deltaTime = 0.020; // 20ms // 0.020sec


// fillRect(x, y, width, height)
// Draws a filled rectangle.
// strokeRect(x, y, width, height)
// Draws a rectangular outline.
// clearRect(x, y, width, height)
// Clears the specified rectangular area, making it fully transparent.

</script>
</body>
</html>
